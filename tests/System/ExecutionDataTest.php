<?php
/**
 * Z-Engine framework
 *
 * @copyright Copyright 2019, Lisachenko Alexander <lisachenko.it@gmail.com>
 *
 * This source file is subject to the license that is bundled
 * with this source code in the file LICENSE.
 *
 */
declare(strict_types=1);

namespace ZEngine\System;

use FFI\CData;
use PHPUnit\Framework\TestCase;
use ZEngine\Core;
use ZEngine\Reflection\ReflectionValue;
use ZEngine\Type\OpLine;

class ExecutionDataTest extends TestCase
{
    public function testHasPrevious()
    {
        $hasPrevious = Core::$executor->getExecutionState()->hasPrevious();
        // This method is definitely called from PHPUnit, so it MUST contain previous entries
        $this->assertTrue($hasPrevious, 'This method is called from PHPUnit, it MUST contain previous entries');
    }

    public function testGetPrevious()
    {
        $executionData = Core::$executor->getExecutionState()->getPrevious();
        $this->assertInstanceOf(ExecutionData::class, $executionData);

        // We can compare our result with backtrace generated by debug_backtrace
        $trace = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 2);
        $this->assertSame($trace[1]['function'], $executionData->getFunction()->getName());
    }

    /**
     * @group internal
     */
    public function testGetSymbolTable()
    {
        $symTable = Core::$executor->getExecutionState()->getSymbolTable();
        $this->assertNotNull($symTable);
        $this->markTestIncomplete('Segfaults if we try to look for local variables');
    }

    /**
     * This test is tricky one to understand: PHP engine allocates a stack frame, where each variable is stored in
     * the stack frame. Thus, $a variable will be stored in first slot in the stack frame and we can access it to check
     */
    public function testGetCallVariableByNumber()
    {
        // Do not use constants here to prevent opcode optimization and inlining
        $expected = microtime(true);

        // $expected will be the first temporary variable in the stack, so index will be 0
        $value = Core::$executor->getExecutionState()->getCallVariableByNumber(0);
        $this->assertInstanceOf(CData::class, $value);

        // Let's check if this value equals to our original $expected
        ReflectionValue::fromValueEntry($value)->getNativeValue($return);
        $this->assertNotNull($return);
        $this->assertSame($expected, $return);
    }

    /**
     * @dataProvider argumentProvider
     */
    public function testGetArguments($arg1 = null, $arg2 = null, $arg3 = null)
    {
        $engineArguments   = Core::$executor->getExecutionState()->getArguments();
        $receivedArguments = [];
        foreach ($engineArguments as $reflectionValue) {
            // We can collect original PHP values from the Core one-by-one
            $reflectionValue->getNativeValue($value);
            $receivedArguments[] = $value;
            unset($value);
        }
        $this->assertEquals(func_get_args(), $receivedArguments);
    }

    /**
     * @dataProvider argumentProvider
     */
    public function testGetNumberOfArguments()
    {
        $engineArguments = Core::$executor->getExecutionState()->getNumberOfArguments();
        $expectedNumber  = func_num_args();
        $this->assertSame($expectedNumber, $engineArguments);
    }

    /**
     * @dataProvider argumentProvider
     */
    public function testGetArgument($firstPhpArgument)
    {
        // Be aware, that getArgument() can return only declared arguments, not extra one!
        $firstArgument = Core::$executor->getExecutionState()->getArgument(0);

        $firstArgument->getNativeValue($firstEngineValue);
        $this->assertInstanceOf(ReflectionValue::class, $firstArgument);
        $this->assertSame($firstPhpArgument, $firstEngineValue);
    }

    public function argumentProvider(): array
    {
        return [
            [1],
            ['a', false],
            [null, new \stdClass, 42.0]
        ];
    }

    public function testGetOpline()
    {
        $opline = Core::$executor->getExecutionState()->getOpline();
        $this->assertSame(__LINE__ - 1, $opline->getLine());
        // we can't do more at the current stage, because code is already executed and we are not in opcode handler
        $this->assertInstanceOf(OpLine::class, $opline);
    }

    public function testGetThis()
    {
        $thisValue = Core::$executor->getExecutionState()->getThis();
        $thisValue->getNativeValue($instance);
        $this->assertSame($this, $instance);

        // Just for fun: we can do crazy things like changing $this in current stack frame
        $self = $this; // Save current $this to call method on it later
        $thisValue->setNativeValue(new \stdClass);
        $self->assertInstanceOf(\stdClass::class, $this);
    }

    public function testGetFunction()
    {
        $reflectionFunction = Core::$executor->getExecutionState()->getFunction();
        $this->assertSame(__FUNCTION__, $reflectionFunction->getName());
    }

    public function testGetCallVariable()
    {
        $this->markTestSkipped('Very engine-specific method');
    }

    public function testGetReturnValue()
    {
        $this->markTestSkipped('It is impossible to check this method, because return value will be overridden by PHP');
    }
}
